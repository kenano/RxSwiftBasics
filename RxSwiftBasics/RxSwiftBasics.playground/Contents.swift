import UIKit
import RxSwift


example(of: "Creating Observables") {
    
    // creating observables.
    // Observable.just creates a single element to be generated by the observable.
    let mostPopular: Observable<String> = Observable<String>.just(episodeV)
    
    // Observable.of generates elements from 1 or more parameters passed to it but they must all be of the same type.
    let originalTrilogy = Observable.of(episodeIV, episodeV, episodeVI)
    
    // the above creates an Observable thatw ill generate 3 strings, not an array of strings.
    // this is how to generate an array of strings.
    let prequelTrilogy = Observable.of([episodeI, episodeII, episodeIII])
    
    // to create an observable that generates all of the items in an array use Observable.from
    let sequelTrilogy = Observable.from([episodeVII, episodeVIII, episodeIX])
}

example(of: "Subscribe to an observable") {
    
    // Create an observable we can subscribe to.
    let originalTrilogy = Observable.of(episodeIV, episodeV, episodeVI)
    
    // print every event generated from the observable. This includes the 3 movies & the completed event.
    // the data generated is wrapred in a next enum.
    // here we are passing in a closure through a trailing closuer.
    originalTrilogy.subscribe { event in
        print(event)
    }
    print("---------")
    
    
    // event is an optional object if it isnt nil we can access the data wrapped in it.
    // do this using the nil coalesing operator.
    originalTrilogy.subscribe {event in
        print(event.element ?? event)
    }
    
    print("---------")
    // event handlers are a big part of Rx. subscribe allows you to pass event handlers for
    // the different kind of events. ie onNext, onCompleted, onError
    // notice the completed event is not being logged this time. since we are assining the closure to the
    // onNext event it is only triggered for onNext events.
    originalTrilogy.subscribe(onNext: {element in
        print(element)
    })
}

// An observable can emit no events. In this case only onError or onCompleted is ever executed.
// Notice the Void type used for the Observable. This could haveen been any type in this example
// since no events are generated.
// onNext will not be executed but onCompleted will.
example(of: "An empty observable") {
    let emptyObservable = Observable<Void>.empty()
    emptyObservable.subscribe(onNext: {element in
        print(element)
        print("---------")
    }, onCompleted: {
        print("completed")
        print("---------")
    })
}

// An observable that never emits anything it also possible. It exits infinetly.
example(of: "An observable that never emits anything") {
    let infiniteObservable = Observable<Any>.never()
    infiniteObservable.subscribe(onNext: {element in
        print(element)
        print("---------")
    }, onCompleted: {
        print("completed")
        print("---------")
    })
}

// To cancel a subsctiption call dispose on the subscription.
// subscriptions are of type disposable. It requires implementation of the dispose method.
// Since this example since only a finite number of elements are emited calling dispose
// really has no effect.
// Some observables will continue to emit events for an indefinite amount of time.
// It is in those situations were it is important to call dispose to cancel.
example(of: "Canceling observables") {
    let originalTrilogy = Observable.of(episodeIV, episodeV, episodeVI)
    let subscription = originalTrilogy.subscribe() {event in
        print(event)
    }
    subscription.dispose()
}


// It can be tedious to manage observables using dispose.
// A common pattern for memory managment is to add all observables an object is using
// to a DisposeBag. The DisposeBag is owned by the object dependent on the observables.
// When this object is about to be deallocated dispose() will be called on all objects
// in disposeBag.
example(of: "Using DisposeBags") {
    let disposeBag = DisposeBag()
    Observable.of(episodeIX, episodeI, episodeV)
        .subscribe() {
            print($0)
        }
        .disposed(by: disposeBag)
    print("---------")
}


// In the previous examples Observable.of, from, empty, never were used to create an observable.
// When using Observable.create we manually trigger the events in the observable.
// Each event we want data generated onNext is called.
// onCompleted must also manually be called after all the data events have been generated.
example(of: "Creating an error event") {
    
    enum Droid: Error {
        case OU812
    }
    
    let disposeBag = DisposeBag()
    
    // the observer is the object who calls subscribe. So we are passing a closure
    // to create which will be executed when subscribe is called.
    Observable<String>.create { observer in
        // onNext are the data events generated by the observable.
        observer.onNext("R2-D2")
        
        // If this line is not commented out then only the previous onNext is generated.
        // once an error event is sent the observable will not generate more events and onDisposed will be executed.
//        observer.onError(Droid.OU812)
        observer.onNext("C3PO")
        observer.onNext("K2SO")
        // the observable will exist until onCompleted is generated.
        observer.onCompleted()
        return Disposables.create()
        }.subscribe(onNext: {print($0)},
                    onError: {print("Error: ", $0)},
                    onCompleted: {print("Completed")},
                    onDisposed: {print("Disposed")})
        .disposed(by: disposeBag)
    print("---------")
    
    // How memory leaks may be created: In the above if no onCompleted or onError is called then the observable will exist until
    // it is canceled. This can be done manually by calling dispose or by adding the observable to a disposeBag which will manully
    // cancel the observable when disposeBags owner is deallocated.
}

// Traits add context to code.
// Single -  will only emit one next event or an error event.
// Completable - will only emit a completed event or error.
// Maybe - will only emit one next event, a completed event, or an error.
//   ? - after the one next event is a completed event also sent?
//


// Using the Single trait is useful when opening/reading a filr. It is a single
// operation which can error out.
example(of: "Using the Single trait") {
    let disposeBag = DisposeBag()
    
    enum FileReadError: Error {
        case fileNoteFound, unreadable, encodingFailed
    }
    
    
    // Single must return a Disposeable
    // Creates an observable which will be subscribed to.
    func loadText(fileName: String) -> Single<String> {
        return Single.create {single in
            let disposable = Disposables.create()
            
            // get the file path
            // an error will be generated in the observable if the file isnt found.
            guard let path = Bundle.main.path(forResource: fileName, ofType: "txt") else {
                single(.error(FileReadError.fileNoteFound))
                return disposable
            }
            
            // read the data or generate an error
            guard let data = FileManager.default.contents(atPath: path) else {
                single(.error(FileReadError.unreadable))
                return disposable
            }
            
            // parse into a String or return the data
            guard let contents = String(data: data, encoding: .utf8) else {
                single(.error(FileReadError.encodingFailed))
                return disposable
            }
            
            // no errors so we can generate a onNext event
            single(.success(contents))
            
            return disposable
        }
    }
    
    // call loadText to generate the observable and subscribe to it.
    // since the single trait is being used handle either the success
    // or error events.
    loadText(fileName: "ANewHope")
        .subscribe {
            switch $0 {
            case .success(let string):
                print(string)
            case .error(let error):
                print(error)
            }
        }
        .disposed(by: disposeBag)
   
}


